use crate::nodes;

grammar;

pub Expr: String = {
  Stream
  // next up: Declaration
}

Stream: String = {
  <inp: InputFunction> <funs:("." <StreamFunction>)*> "." <out: OutputFunction> => {
      let exp = nodes::StreamNode {
        inp,
        funs,
        out
      };
      exp.code()
    },
}

InputFunction: nodes::InputFunctionNode = {
  "range(" <n1: r"[0-9]+"> "," <n2: r"[0-9]+"> ")" => nodes::InputFunctionNode{
    variability: nodes::InputVariability::Constant,
    input_count: nodes::InputCount::Known((n2.parse::<num_bigint::BigInt>().unwrap() - n1.parse::<num_bigint::BigInt>().unwrap()).to_biguint().unwrap()),
    code: format!("crate::marigold::marigold_impl::futures::stream::iter({n1}..{n2})"),
  }
}

StreamFunction: nodes::StreamFunctionNode = {
  "permutations("<n: r"[0-9]+"> ")" => nodes::StreamFunctionNode {
    code: format!("permutations({n}).await")
  },
  "combinations("<n: r"[0-9]+"> ")" =>  nodes::StreamFunctionNode {
    code: format!("combinations({n}).await")
  },
  "keep_first_n(" <n: r"[0-9]+"> "," <value_fn: r"[a-zA-Z_]+"> ")" =>  nodes::StreamFunctionNode {
    code: format!("keep_first_n({n}, {value_fn}).await")
  },
}

OutputFunction: String = {
  "return" => "".to_string()
}
